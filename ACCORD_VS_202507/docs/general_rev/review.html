<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Carlos Peralta">
<meta name="dcterms.date" content="2025-08-11">

<title>Spatial Verification Techniques for Extreme Events: A Review</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="review_files/libs/clipboard/clipboard.min.js"></script>
<script src="review_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="review_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="review_files/libs/quarto-html/popper.min.js"></script>
<script src="review_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="review_files/libs/quarto-html/anchor.min.js"></script>
<link href="review_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="review_files/libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="review_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="review_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="review_files/libs/bootstrap/bootstrap-9c15a5338fb2cec66ee684ebdf9d454e.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">


</head>

<body class="quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction">Introduction</a></li>
  <li><a href="#classification-of-spatial-verification-techniques" id="toc-classification-of-spatial-verification-techniques" class="nav-link" data-scroll-target="#classification-of-spatial-verification-techniques">Classification of Spatial Verification Techniques</a>
  <ul class="collapse">
  <li><a href="#fuzzy-neighborhood-based-methods" id="toc-fuzzy-neighborhood-based-methods" class="nav-link" data-scroll-target="#fuzzy-neighborhood-based-methods">1. Fuzzy / Neighborhood-Based Methods</a></li>
  <li><a href="#scale-decomposition-techniques" id="toc-scale-decomposition-techniques" class="nav-link" data-scroll-target="#scale-decomposition-techniques">2. Scale-Decomposition Techniques</a></li>
  <li><a href="#feature-based-object-oriented-techniques" id="toc-feature-based-object-oriented-techniques" class="nav-link" data-scroll-target="#feature-based-object-oriented-techniques">3. Feature-Based / Object-Oriented Techniques</a></li>
  <li><a href="#field-deformation-displacementamplitude-approaches" id="toc-field-deformation-displacementamplitude-approaches" class="nav-link" data-scroll-target="#field-deformation-displacementamplitude-approaches">4. Field Deformation / Displacement–Amplitude Approaches</a></li>
  <li><a href="#other-relevant-techniques" id="toc-other-relevant-techniques" class="nav-link" data-scroll-target="#other-relevant-techniques">Other Relevant Techniques</a>
  <ul class="collapse">
  <li><a href="#distance-metrics-for-binary-images" id="toc-distance-metrics-for-binary-images" class="nav-link" data-scroll-target="#distance-metrics-for-binary-images">Distance Metrics for Binary Images</a></li>
  </ul></li>
  <li><a href="#observational-challenges-in-spatial-verification" id="toc-observational-challenges-in-spatial-verification" class="nav-link" data-scroll-target="#observational-challenges-in-spatial-verification">Observational Challenges in Spatial Verification</a></li>
  </ul></li>
  <li><a href="#conclusion-and-future-directions" id="toc-conclusion-and-future-directions" class="nav-link" data-scroll-target="#conclusion-and-future-directions">Conclusion and Future Directions</a></li>
  <li><a href="#references" id="toc-references" class="nav-link" data-scroll-target="#references">References</a></li>
  </ul>
</nav>
</div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Spatial Verification Techniques for Extreme Events: A Review</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Carlos Peralta </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">August 11, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="introduction" class="level1">
<h1>Introduction</h1>
<p>High-resolution numerical weather prediction (NWP) models require verification methods that go beyond traditional gridpoint-based metrics such as mean squared error (MSE) or equitable threat score (ETS). These methods often suffer from the <strong>double penalty problem</strong> (Anthes 1983): forecasts are penalized once for placing a feature in the wrong location, and again for missing the feature in the correct location. This can lead to misleadingly low scores even if the forecast has the right intensity, structure, or timing but a small displacement error.</p>
<p>The double penalty problem is particularly pronounced for <strong>extreme events</strong> such as intense precipitation, convection, or tropical cyclones, where small spatial shifts can result in large discrepancies at individual grid points. To address this, spatial verification techniques were developed that explicitly account for:</p>
<ul>
<li><p>Field <strong>spatial structures</strong> and coherent features (Casati 2010)</p></li>
<li><p><strong>Displacement errors</strong> vs.&nbsp;<strong>intensity errors</strong></p></li>
<li><p><strong>Scale-dependent skill</strong>, revealing performance over different spatial extents</p></li>
</ul>
<p>Following Gilleland et al.&nbsp;(2009) and recent developments (Casati et al.&nbsp;2004; Davis et al.&nbsp;2006; Wernli et al.&nbsp;2008), spatial verification techniques can be grouped into four main categories.</p>
</section>
<section id="classification-of-spatial-verification-techniques" class="level1">
<h1>Classification of Spatial Verification Techniques</h1>
<section id="fuzzy-neighborhood-based-methods" class="level2">
<h2 class="anchored" data-anchor-id="fuzzy-neighborhood-based-methods">1. Fuzzy / Neighborhood-Based Methods</h2>
<p><strong>Concept:</strong></p>
<p>Relax the requirement for exact gridpoint matching by allowing spatial (and sometimes temporal) tolerance. The idea is to assess agreement within a local neighborhood.</p>
<p><strong>Approach:</strong></p>
<p>For each gridpoint in the forecast, a surrounding neighborhood is defined. The fraction of points within the neighborhood exceeding a threshold (e.g., rain &gt; 1 mm/h) is compared between forecast and observation. A classical example of this approach is the <strong>Fractions Skill Score (FSS)</strong> (Roberts &amp; Lean 2008).</p>
<p><strong>Examples:</strong></p>
<ul>
<li><p>Fractions Skill Score (FSS) (Roberts &amp; Lean 2008)</p></li>
<li><p>Spatial multi-event ROC curves (Atger 2001)</p></li>
<li><p>Distance-dependent POD and POFD (Tremblay et al.&nbsp;1996)</p></li>
<li><p>Rank-based neighborhood RMSE (Rezacova &amp; Sokol 2005)</p></li>
<li><p>Theis et al.&nbsp;(2005) probability-from-neighborhood approach</p></li>
<li><p>Structure of Local Extremes (SLX) (Sass, 2021)</p></li>
</ul>
<p><strong>Pros:</strong></p>
<ul>
<li><p>Intuitive interpretation</p></li>
<li><p>Easy to implement for high-resolution fields</p></li>
<li><p>Naturally bridges deterministic and probabilistic verification</p></li>
</ul>
<p><strong>Cons:</strong></p>
<ul>
<li><p>May smooth out displacement patterns</p></li>
<li><p>Loses information on exact positional errors</p></li>
</ul>
<p><strong>Applications for extremes:</strong></p>
<p>Used for precipitation verification in convection-permitting models, where exact positioning of convective cores is less important than capturing spatial coverage.</p>
<hr>
</section>
<section id="scale-decomposition-techniques" class="level2">
<h2 class="anchored" data-anchor-id="scale-decomposition-techniques">2. Scale-Decomposition Techniques</h2>
<p><strong>Concept:</strong><br>
Decompose the forecast and observed fields into components associated with different spatial scales, allowing verification per scale.</p>
<p><strong>Approach:</strong></p>
<p>Apply transforms (wavelet, Fourier, discrete cosine) to separate large-scale and small-scale features. Compare components at each scale using continuous scores, categorical scores, or probabilistic measures.</p>
<p><strong>Key methods:</strong></p>
<ul>
<li><p><strong>Intensity-Scale Skill Score</strong> (Casati et al.&nbsp;2004): Uses 2D Haar wavelet decomposition of binary precipitation fields for multiple thresholds, computes skill at each combination of intensity and scale.</p></li>
<li><p><strong>Wavelet-based verification</strong> (Briggs &amp; Levine 1997; Casati &amp; Wilson 2007)</p></li>
<li><p>Fourier/cosine decomposition for predictability studies (Denis et al.&nbsp;2003)</p></li>
</ul>
<p><strong>Pros:</strong></p>
<ul>
<li><p>Identifies scales where the model has/no skill</p></li>
<li><p>Links forecast errors to physical processes (e.g., missing mesoscale organization)</p></li>
<li><p>Useful for predictability analysis</p></li>
</ul>
<p><strong>Cons:</strong> - Complex implementation and interpretation - Doesn’t always explicitly separate displacement from amplitude errors</p>
<p><strong>Applications for extremes:</strong></p>
<p>Rainfall intensity–scale diagrams help assess the model’s ability to reproduce convective vs stratiform components of extreme precipitation.</p>
<hr>
</section>
<section id="feature-based-object-oriented-techniques" class="level2">
<h2 class="anchored" data-anchor-id="feature-based-object-oriented-techniques">3. Feature-Based / Object-Oriented Techniques</h2>
<p><strong>Concept:</strong><br>
Identify discrete meteorological features (objects) in both forecast and observed fields, then compare their properties.</p>
<p><strong>Approach:</strong></p>
<ol type="1">
<li><p>Apply a threshold to define objects (e.g., contiguous areas of rain &gt; X mm/h).</p></li>
<li><p>Match forecast and observed objects using distance and overlap criteria.</p></li>
<li><p>Compare attributes: centroid location, area, orientation, intensity.</p></li>
</ol>
<p><strong>Examples:</strong></p>
<ul>
<li><p><strong>Ebert &amp; McBride (2000)</strong> object matching for precipitation systems</p></li>
<li><p><strong>MODE</strong> (Davis et al.&nbsp;2006) – filters, identifies, matches objects</p></li>
<li><p><strong>SAL score</strong> (Wernli et al.&nbsp;2008) – compares Structure, Amplitude, Location</p></li>
<li><p>Cluster analysis (Marzban &amp; Sandgathe 2006)</p></li>
</ul>
<p><strong>Pros:</strong></p>
<ul>
<li><p>Physically interpretable diagnostics (size, shape, displacement)</p></li>
<li><p>Allows event-based verification</p></li>
</ul>
<p><strong>Cons:</strong></p>
<ul>
<li><p>Sensitive to object identification parameters (threshold, smoothing)</p></li>
<li><p>Difficult for diffuse or overlapping features</p></li>
</ul>
<p><strong>Applications for extremes:</strong></p>
<p>Identification and verification of mesoscale convective systems (MCSs) in warm-season extreme rainfall forecasts.</p>
<hr>
</section>
<section id="field-deformation-displacementamplitude-approaches" class="level2">
<h2 class="anchored" data-anchor-id="field-deformation-displacementamplitude-approaches">4. Field Deformation / Displacement–Amplitude Approaches</h2>
<p><strong>Concept:</strong><br>
Rather than isolating features or scales, treat the entire field as a continuous pattern. Estimate the transformation (shift, rotation, stretching) that best aligns the forecast with observations.</p>
<p><strong>Approach:</strong></p>
<ul>
<li><p>Optical flow or variational matching is used to morph the forecast field into the observation.</p></li>
<li><p>The transformation encodes <strong>displacement errors</strong>, and residual intensities after correction represent <strong>amplitude errors</strong> (Hoffman et al.&nbsp;1995; Keil &amp; Craig 2009).</p></li>
</ul>
<p><strong>Examples:</strong></p>
<ul>
<li><p>Displacement–Amplitude Score (DAS, Keil &amp; Craig 2009)</p></li>
<li><p>Field alignment methods for radar nowcasting</p></li>
</ul>
<p><strong>Pros:</strong></p>
<ul>
<li><p>Captures spatial and amplitude errors jointly</p></li>
<li><p>Avoids explicit object definition</p></li>
</ul>
<p><strong>Cons:</strong></p>
<ul>
<li><p>Computationally intensive</p></li>
<li><p>Interpretation can be less intuitive for end-users</p></li>
</ul>
<hr>
</section>
<section id="other-relevant-techniques" class="level2">
<h2 class="anchored" data-anchor-id="other-relevant-techniques">Other Relevant Techniques</h2>
<section id="distance-metrics-for-binary-images" class="level3">
<h3 class="anchored" data-anchor-id="distance-metrics-for-binary-images">Distance Metrics for Binary Images</h3>
<p>Quantify positional errors between binary feature masks:</p>
<ul>
<li><p><strong>Hausdorff distance</strong></p></li>
<li><p><strong>Baddeley’s Δ metric</strong> (Baddeley 1992)</p></li>
<li><p><strong>Pratt’s figure of merit</strong></p></li>
</ul>
<p>These metrics account for both feature shape and location differences and can complement categorical scores (Venugopal et al.&nbsp;2005; Gilleland et al.&nbsp;2006).</p>
<hr>
</section>
</section>
<section id="observational-challenges-in-spatial-verification" class="level2">
<h2 class="anchored" data-anchor-id="observational-challenges-in-spatial-verification">Observational Challenges in Spatial Verification</h2>
<p>Casati’s work highlights that spatial verification performance depends critically on observational coverage:</p>
<ul>
<li><p><strong>Gauge networks</strong>: sparse coverage limits ability to verify small-scale features.</p></li>
<li><p><strong>Radars</strong>: subject to biases in quantitative precipitation estimation (QPE), incomplete domain coverage.</p></li>
<li><p><strong>Satellites</strong>: high coverage but uncertain for precipitation intensity.</p></li>
</ul>
<p><strong>Wavelet-based observation reconstruction</strong> (Casati 2010): reconstructs a gridded precipitation field from sparse gauges using Haar wavelets, preserving known values at gauges and inferring large-scale structure.</p>
<hr>
</section>
</section>
<section id="conclusion-and-future-directions" class="level1">
<h1>Conclusion and Future Directions</h1>
<p>Spatial verification has matured into a diverse toolkit, each method suited to particular forecast types and user needs:</p>
<ul>
<li><p>Neighborhood methods excel for general spatial coverage evaluation.</p></li>
<li><p>Scale separation is key for model development and process studies.</p></li>
<li><p>Object methods are best for event-focused studies.</p></li>
<li><p>Field deformation captures displacement dynamics.</p></li>
</ul>
<p><strong>Future priorities:</strong></p>
<ul>
<li><p>Hybrid approaches combining scale/object/displacement aspects</p></li>
<li><p>Verification metrics tailored for impact forecasting</p></li>
<li><p>Integration of uncertainty (probabilistic forecasts, ensemble verification)</p></li>
<li><p>Machine learning for feature detection and verification automation</p></li>
</ul>
<hr>
</section>
<section id="references" class="level1">
<h1>References</h1>
<ul>
<li>Anthes, R. A. (1983). Regional models of the atmosphere in middle latitudes. <em>Mon. Wea. Rev.</em>, 111, 1306–1335.</li>
<li>Atger, F. (2001). Verification of intense precipitation forecasts from single models and ensemble prediction systems. <em>Nonlinear Processes in Geophysics</em>, 8, 401–417.</li>
<li>Baddeley, A. (1992). An error metric for binary images. In <em>Robotics and Automation, 1992. Proceedings.</em>, vol.&nbsp;1, 172–178.</li>
<li>Briggs, W. M., &amp; Levine, R. A. (1997). Wavelets and field forecast verification. <em>Mon. Wea. Rev.</em>, 125, 1329–1341.</li>
<li>Casati, B., et al.&nbsp;(2004). A new intensity-scale approach for the verification of spatial precipitation forecasts. <em>Meteorological Applications</em>, 11(2), 141–154.</li>
<li>Casati, B., &amp; Wilson, L. J. (2007). A new spatial–scale decomposition approach to forecast verification. <em>Mon. Wea. Rev.</em>, 135, 1829–1849.</li>
<li>Davis, C., Brown, B., &amp; Bullock, R. (2006). Object-based verification of precipitation forecasts. <em>Mon. Wea. Rev.</em>, 134, 1772–1784.</li>
<li>Denis, B., et al.&nbsp;(2003). Downscaling ability of one-way nested regional climate models. <em>Clim. Dyn.</em>, 21, 501–516.</li>
<li>Gilleland, E., et al.&nbsp;(2006). Spatial forecast verification: Image warping. <em>Wea. Forecasting</em>, 21, 757–766.</li>
<li>Gilleland, E., Ahijevych, D., Brown, B. G., Casati, B., &amp; Ebert, E. E. (2009). Intercomparison of spatial forecast verification methods. <em>Wea. Forecasting</em>, 24, 1416–1430.</li>
<li>Hoffman, R. N., et al.&nbsp;(1995). The influence of data resolution on forecast skill. <em>Mon. Wea. Rev.</em>, 123, 2665–2681.</li>
<li>Keil, C., &amp; Craig, G. C. (2009). A displacement and amplitude score employing an optical flow technique. <em>Wea. Forecasting</em>, 24, 1297–1308.</li>
<li>Marzban, C., &amp; Sandgathe, S. (2006). Cluster analysis for verification. <em>Wea. Forecasting</em>, 21, 824–838.</li>
<li>Roberts, N., &amp; Lean, H. W. (2008). Scale-selective verification of rainfall accumulations from high-resolution forecasts. <em>Mon. Wea. Rev.</em>, 136, 78–97.</li>
<li>Sass, B. H. (2021) A scheme for verifying the spatial structure of extremes in numerical weather prediction: Exemplified for precipitation. <em>Meteorol Appl.</em> 2021;28:e2015.</li>
<li>Venugopal, V., et al.&nbsp;(2005). Scaling relations and self-similarity in rainfall. <em>J. Geophys. Res.</em>, 110, D14102.</li>
<li>Wernli, H., Paulat, M., Hagen, M., &amp; Frei, C. (2008). SAL—A novel quality measure for the verification of quantitative precipitation forecasts. <em>Mon. Wea. Rev.</em>, 136, 4470–4487. ```</li>
</ul>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>