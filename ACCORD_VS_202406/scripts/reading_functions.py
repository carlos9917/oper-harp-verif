################################################################################
# Exploring the use of python to interface with R reticulate

# Authors: F. Baordo (DMI) + Schmederer Polly (geosphere) ACCORD VS June 2024 

# Dependedncy: Python Metview + Satpy

# On ATOS, load the following modules before using R
#
# module load python3/3.11.8-01
# module load ecmwf-toolbox/2024.04.0.0 --> necessary to use the metview python interface

# In R load/source:
#
# library(reticulate)
# use_python("/perm/miag/venvs/satpy/bin/python3") --> to use virtual env where satpy is installed (rx for accord group)
# source_python("reading_functions.py")            --> source this python code

# Extracting variables from grib files using the metview python interface 

# We extrac the variable using the correpsonding grib message. 
# We need to do to this because simulated radiances in our grib files are 'unkown'. 
# Alternatively, if shortName, typeOfLevel, stepRange (and so on) are know, variables can be extracted following this example: 
# myFC  = mv.read(grbFile) 
# myVar = myFC.select(shortName="tirf", typeOfLevel="surface", stepRange="0-36")
################################################################################

import metview as mv
import os
import numpy as np

from satpy.scene import Scene
import pyresample as pr
from pyresample import get_area_def
from pyproj import Proj

import matplotlib.pyplot as plt
import cartopy.crs as ccrs

import warnings
warnings.filterwarnings('ignore')

# diagPlots = True --> To check map of obs/model
diagPlots = False
pathDiagPlots = os.path.join(os.environ['HOME'],'reticualte_diag_plots')
###################################
# Call get_grb_message from R
###################################
# Example:
# grbFile <- "/perm/miag/ACCORD_VS/deode_exps/2024010200/harmonie_DK2500g_SP_HRES_jan/surface_gc_300x300_2500m+0022h00m00s.grb"
# messnum <- 23
# myList <- get_grb_message(grbFile, messnum)

def get_grb_message (grbFile, messNun):
    """
    Input: grib file and message to extract. We use the python metview interface to read the grib file
    Output: List containing: [data (1D), lat (1D), lon (1D), strANtime, strValidTime, strFcStep, dictAttributes]
    """
    
    messNun = int(messNun)
    print('Extracting grib message {0} from grib file {1}'.format(messNun,grbFile))

    returnList = []
    listContent = ['data', 'lat', 'lon', 'ANtime', 'ValidTime', 'FcStep', 'Attributes']
    
    myFC = mv.read(grbFile) 
    
    # This is necessary for grib generated by the DEODE workflow (check first message)   
    if myFC[messNun - 1].ls()['gridType'][0] == 'lambert_lam':
        myFC = mv.grib_set(myFC,['gridType','lambert'])

    # python index start from 0, hence to get the right num message '-1'
    var = myFC[messNun - 1]

    myData  = var.to_dataset()
    varname = list(myData.keys())[0]

    strANtime    = str(myData.time.data)
    strValidTime = str(myData.valid_time.data)
    strFcStep    = str(np.timedelta64(myData.step.data,'h'))

    returnList.append(myData[varname].data)
    returnList.append(myData.latitude.data)
    returnList.append(myData.longitude.data)
    returnList.append(strANtime)
    returnList.append(strValidTime)
    returnList.append(strFcStep)
    returnList.append(myData[varname].attrs)

    print('  Var name extracted: {0}'.format(varname))
    print('  AN time: {0}'.format(strANtime))
    print('  Valid time: {0}'.format(strValidTime))
    print('  FC step: {0}'.format(strFcStep))
    print('  Content of returned list: {0}'.format(listContent))

    return returnList

###################################
# Call get_msg_data from R
###################################
# Example:
# msgFile <- "/perm/miag/ACCORD_VS/MSG/20231221/MSG3-SEVI-MSG15-0100-NA-20231221055743.166000000Z-NA.nat"
# strChannel <-"WV_062"
# ll_box <- list(3, 52, 17, 58, TRUE)
# myList <- get_msg_data (msgFile, strChannel, ll_box)

def get_msg_data (msgFile, strChannel, ll_box):
    """
    Input: MSG file (naitve), strChannel and ll_box. We use the python satpy to read the MSG file.
    strChannel --> 'WV_062', 'IR_108'
    ll_box --> to select lat/lon region: ll_bbox=(lon_min, lat_min, lon_max, lat_max)
    Output: List containing: [data (1D), lat (1D), lon (1D), dictAttributes]
    """
    
    returnList = []
    listContent = ['data', 'lat', 'lon', 'Attributes']

    print('Extracting data from MSG file {0}, channel {1} and ll_box {2}'.format(msgFile,strChannel,ll_box))
    
    strReader      = 'seviri_l1b_native'
    strCalibration = 'brightness_temperature'

    scn = Scene(reader=strReader, filenames=[msgFile])

    channelsAv = scn.available_dataset_names()

    if strChannel not in channelsAv:
        print('WARNING: strChannel {0} not found in available dataset {1}'.format(strChannel,channelsAv))
        print('--> return empty list!')
        return returnList

    
    scn.load([strChannel], upper_right_corner='NE', calibration=[strCalibration])
    
    scn_cropped = scn.crop(ll_bbox=ll_box)

    lon, lat = scn_cropped[strChannel].attrs['area'].get_lonlats()
    data = scn_cropped[strChannel].values
    attrs = scn_cropped[strChannel].attrs
        
    returnList.append(data)
    returnList.append(lat)
    returnList.append(lon)
    returnList.append(attrs)
        
    print('  Content of returned list: {0}'.format(listContent))
         
    return returnList

###################################
# function to have diagnostic plots of resampled data
###################################
def diag_resample_plots(data_sim_resample, data_sat_resample, lon_resample, lat_resample, strChannel,strRes):

    #print('  data resample sat min/max {0}/{1}'.format(np.nanmin(data_sat_resample),np.nanmax(data_sat_resample)))
    #print('  data resample model min/max {0}/{1}'.format(np.nanmin(data_sim_resample),np.nanmax(data_sim_resample)))

    # fix the scale accoriding to obs
    myMin  = int(np.nanmin(data_sat_resample))
    myMax  = int(np.nanmax(data_sat_resample))

    myMin_model  = int(np.nanmin(data_sim_resample))
    myMax_model  = int(np.nanmax(data_sim_resample))
    
    if strChannel == 'WV_062':
        myStep = 2
    else:
        myStep = 5
    
    bounds = np.arange(myMin,myMax,myStep)

    strCmap = 'gist_yarg'

    width_F  = 12
    height_F = 10

    plt.figure(figsize=(width_F,height_F),dpi=100)
    
    ax = plt.subplot(2, 1, 1, projection=ccrs.PlateCarree())
    
    im = plt.pcolormesh(lon_resample, lat_resample, data_sat_resample,transform=ccrs.PlateCarree(),cmap=strCmap, vmin=bounds[0], vmax=bounds[len(bounds)-1]) 
                   
    ax.coastlines()
    ax.gridlines(draw_labels=["top", "left"])
    
    plt.colorbar(im, location='bottom', boundaries=bounds,ticks=bounds,extend='both',shrink=0.7, pad=0.06) #spacing='proportional'
    
    plt.title(strChannel + ' Satellite data resampled to '+ strRes +' \n min/max: ' + str(myMin) + '/' + str(myMax))
    
    ax = plt.subplot(2, 1, 2, projection=ccrs.PlateCarree())
    
    im = plt.pcolormesh(lon_resample, lat_resample, data_sim_resample,transform=ccrs.PlateCarree(),cmap=strCmap, vmin=bounds[0], vmax=bounds[len(bounds)-1]) 
                   
    ax.coastlines()
    ax.gridlines(draw_labels=["top", "left"])
    
    plt.colorbar(im, location='bottom', boundaries=bounds,ticks=bounds,extend='both',shrink=0.7, pad=0.06) #spacing='proportional'

    plt.title('Model simulated data' + '\n min/max: ' + str(myMin_model) + '/' + str(myMax_model))

    if not os.path.exists(pathDiagPlots):
        os.makedirs(pathDiagPlots)
            
    myPng = 'diag_plot.resampledData.'+strRes+'.'+strChannel +'.png'
    plotname = os.path.join(pathDiagPlots, myPng)    
    plt.savefig(plotname)

    print(' --> diag plot saved as: ' +plotname)
    
    return None

######################################################
# function adapted from satpy coord2area_def.py which is used like:
# python3 coord2area_def.py "name proj min_lat max_lat min_lon max_lon resolution(km)"
# String proj: use proj.4 names, like laea, stere, merc...
# 'laea' --> Lambert azimuthal equal-area projection
######################################################
def satpy_coord2aea_def(strName, strProj, min_lon, max_lon, min_lat, max_lat, resolution):

    name = strName
    proj = strProj

    left  = min_lon
    right = max_lon
    up    = min_lat
    down  = max_lat

    res = resolution * 1000

    lat_0 = (up + down) / 2
    lon_0 = (right + left) / 2

    p = Proj(proj=proj, lat_0=lat_0, lon_0=lon_0, ellps="WGS84")

    left_ex1, up_ex1 = p(left, up)
    right_ex1, up_ex2 = p(right, up)
    left_ex2, down_ex1 = p(left, down)
    right_ex2, down_ex2 = p(right, down)
    left_ex3, dummy = p(left, lat_0)
    right_ex3, dummy = p(right, lat_0)

    area_extent = (min(left_ex1, left_ex2, left_ex3),
                   min(up_ex1, up_ex2),
                   max(right_ex1, right_ex2, right_ex3),
                   max(down_ex1, down_ex2))

    xsize = int(round((area_extent[2] - area_extent[0]) / res))
    ysize = int(round((area_extent[3] - area_extent[1]) / res))

    proj4_string = "+" + \
        " +".join(("proj=" + proj + ",lat_0=" + str(lat_0) +
                   ",lon_0=" + str(lon_0) + ",ellps=WGS84").split(","))

    proj_id_string = proj +'_'+str(lat_0)+'_'+str(lon_0)

    dict_domain = {'area_extent': (area_extent[0], area_extent[1], area_extent[2], area_extent[3]), 
                   'projection':  proj4_string, 
                   'proj_id':     proj_id_string,
                   'x_size': xsize,
                   'y_size': ysize,
                   'lat_0': lat_0,
                   'lon_0': lon_0
                  }
    
    return dict_domain

###################################
# function to get areadef from string 'area_id'
###################################
def get_areadef_domanin(area_id):

    # expected input aread_id: [SW_lat SW_lon NE_lat NE_lon resKm strproj]
    SW_lat = float(area_id[0])  
    SW_lon = float(area_id[1]) 
    NE_lat = float(area_id[2]) 
    NE_lon = float(area_id[3])
    resKm = float(area_id[4])
    strproj = area_id[5]
    
    print('***************************************************')
    print('Input area_id (target domain):')
    print('SW_lat {}'.format(SW_lat))
    print('SW_lon {}'.format(SW_lon))
    print('NE_lat {}'.format(NE_lat))
    print('NE_lon {}'.format(NE_lon))
    print('Resolution (km) {}'.format(resKm))
    print('String proj [use proj.4 names, like laea , stere, merc...] {}'.format(strproj))
    print(' ')

    strName = 'satpy_coord2aea_def'
    dict_domain = satpy_coord2aea_def(strName, strproj, SW_lon, NE_lon, SW_lat, NE_lat, resKm)

    area_extent = dict_domain['area_extent']
    projection  = dict_domain['projection']
    proj_id     = dict_domain['proj_id']
    lat_0       = dict_domain['lat_0']
    lon_0       = dict_domain['lon_0']
    x_size       = dict_domain['x_size']
    y_size       = dict_domain['y_size']

    # from km to meters
    dx = dy = interpolradius = resKm*1000

    areadef = get_area_def(strName, strName, proj_id, projection, x_size, y_size, area_extent)

    print('Created areadef: ' )
    print(str(areadef))
    print('***************************************************')

    dictDomainForR = {'SW_lon': SW_lon, 
                      'SW_lat': SW_lat, 
                      'NE_lon': NE_lon,
                      'NE_lat': NE_lat, 
                      'lat_0': lat_0, 
                      'lon_0': lon_0,
                      'dx': dx,
                      'dy': dy,
                      'nx': x_size,
                      'ny': y_size,
                      'proj': strproj}
    
    return areadef, interpolradius, dictDomainForR

###################################
# Call sat_model_to_same_grid from R
###################################
# Example (resemple to 2.5 km model resolution):
# msgFile <- "/perm/miag/ACCORD_VS/MSG/20240102/MSG3-SEVI-MSG15-0100-NA-20240102215743.453000000Z-NA.nat"
# strChannel <-"IR_108"
# grbFile <- "/perm/miag/ACCORD_VS/deode_exps/2024010200/harmonie_DK2500g_SP_HRES_jan/surface_gc_300x300_2500m+0022h00m00s.grb"
# messnum  <- 24
# areaId <- c(53, 6.5, 58.5, 16.5, 2.5, 'laea')
# myList <- sat_model_to_same_grid(msgFile, strChannel, grbFile, messnum, areaId)
def sat_model_to_same_grid (msgFile, strChannel, grbFile, messNun, areaId):
    """
    Input: 
    MSG file (native)
    strChannel, expected from MSG file e.g. 'WV_062', 'IR_108'
    grib file 
    message to extract model variable (corresponding simulated radiance) from grib file
    areaId to identify target domain: (SW_lat, SW_lon, NE_lat, NE_lon, resKm, strproj)    
    Output: List containing: [data_sat (1D), data_model (1D), lat (1D), lon (1D), dictDomain, strValidTime]
    """
    
    returnList = []
    listContent = ['data_sat_resampled', 'data_model_resampled', 'lat_resampled', 'lon_resampled', 'dictDomain','strValidTime']

    print('****** Python Interface: Model/Observations will be interpolated to common grid ******')
    
    areadef, interpolradius, dictDomain = get_areadef_domanin(areaId)

    # WORKING ON SATELITE DATA
    print(' --> Extracting data from MSG file {0}, channel {1} '.format(msgFile,strChannel))
    
    strReader      = 'seviri_l1b_native'
    strCalibration = 'brightness_temperature'

    scn = Scene(reader=strReader, filenames=[msgFile])

    channelsAv = scn.available_dataset_names()

    if strChannel not in channelsAv:
        print('ERROR: strChannel {0} not found in available dataset {1}'.format(strChannel,channelsAv))
        print('--> return empty list!')
        sys.exit(1)

    scn.load([strChannel], upper_right_corner='NE', calibration=[strCalibration])    
    scn_resample = scn.resample(areadef, resampler='nearest')

    lon_resample, lat_resample = scn_resample[strChannel].attrs['area'].get_lonlats()
    data_sat_resample          = scn_resample[strChannel].values

    print(' --> Resempled satellite data shape is {}'.format(data_sat_resample.shape))

    # WORKING ON MODEL DATA
    messNun = int(messNun)

    print(' --> Extracting grib message {0} from grib file {1}'.format(messNun,grbFile))
    
    myFC = mv.read(grbFile) 

    strCheck = myFC[messNun - 1].ls()['gridType'][0]
    # This is necessary for grib generated by the DEODE workflow (check first message)   
    if strCheck == 'lambert_lam':
        myFC = mv.grib_set(myFC,['gridType','lambert'])

    # python index start from 0, hence to get the right num message '-1'
    var = myFC[messNun - 1]

    myData  = var.to_dataset()
    varname = list(myData.keys())[0]

    data_sim = myData[varname].data
    lat_sim  = myData.latitude.data
    lon_sim  = myData.longitude.data

    strANtime    = str(myData.time.data)
    strValidTime = str(myData.valid_time.data)

    print(' --> Model data input shape {}'.format(data_sim.shape))
    print(' --> Model data ANtime {}'.format(strANtime))
    print(' --> Model data validtime {}'.format(strValidTime))
    
    orig_def = pr.geometry.GridDefinition(lons=lon_sim, lats=lat_sim)

    # We put everything on the same grid, we consider interpolradius == model NWP resolution     
    # radius_of_influence: The radius around each grid pixel in meters to search for neighbours in the swath
    # epsilon: The distance to a found value is guaranteed to be no further than (1 + eps) times the distance to the correct neighbour 
    data_sim_resample = pr.kd_tree.resample_nearest(orig_def, 
                                                   data_sim,
                                                   areadef,
                                                   radius_of_influence = interpolradius, 
                                                   epsilon = 0.5,
                                                   fill_value = np.nan)

    print(' --> Resempled Model data shape is {}'.format(data_sim_resample.shape))

    if diagPlots:
        print(' --> Diagnostic map plots to check resampled data...')
        resKm = float(areaId[4])
        resM = int(resKm*1000)
        strRes = str(resM)+'m'
        diag_resample_plots(data_sim_resample, data_sat_resample, lon_resample, lat_resample, strChannel,strRes)

    returnList.append(data_sat_resample)
    returnList.append(data_sim_resample)
    returnList.append(lat_resample)
    returnList.append(lon_resample)
    returnList.append(dictDomain)
    returnList.append(strValidTime)
    
    print(' --> Content of returned list: {0}'.format(listContent))
    print('****** Python Interface End ******')
    return returnList



def get_data_nc_file(ncFile,parameter):
    """
    Read the data from an nc file using xarray
    and return the it in the right format
    """
    import pandas as pd
    import numpy as np
    ds = xr.open_dataset(ncFile)
    time = pd.to_datetime(ds["time"].values[0],unit="s")
    returnList=[]
    returnList.append(np.asmatrix(ds[parameter].values))
    returnList.append(ds["lat"].values)
    returnList.append(ds["lon"].values)
    returnList.append(ds.attrs)
    returnList.append(time)


    return returnList

